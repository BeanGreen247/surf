
/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */


#include <glib-object.h>
#include "gcr/gcr-certificate-chain.h"
/* enumerations from "gcr/gcr-certificate-chain.h" */
GType gcr_certificate_chain_status_get_type (void) G_GNUC_CONST;

GType
gcr_certificate_chain_status_get_type (void)
{
    static GType etype = 0;
    if (G_UNLIKELY(etype == 0)) {
        static const GEnumValue values[] = {
            { GCR_CERTIFICATE_CHAIN_UNKNOWN, "GCR_CERTIFICATE_CHAIN_UNKNOWN", "unknown" },
            { GCR_CERTIFICATE_CHAIN_INCOMPLETE, "GCR_CERTIFICATE_CHAIN_INCOMPLETE", "incomplete" },
            { GCR_CERTIFICATE_CHAIN_DISTRUSTED, "GCR_CERTIFICATE_CHAIN_DISTRUSTED", "distrusted" },
            { GCR_CERTIFICATE_CHAIN_SELFSIGNED, "GCR_CERTIFICATE_CHAIN_SELFSIGNED", "selfsigned" },
            { GCR_CERTIFICATE_CHAIN_PINNED, "GCR_CERTIFICATE_CHAIN_PINNED", "pinned" },
            { GCR_CERTIFICATE_CHAIN_ANCHORED, "GCR_CERTIFICATE_CHAIN_ANCHORED", "anchored" },
            { 0, NULL, NULL }
        };
        etype = g_enum_register_static (g_intern_static_string ("GcrCertificateChainStatus"), values);
    }
    return etype;
}
GType gcr_certificate_chain_flags_get_type (void) G_GNUC_CONST;

GType
gcr_certificate_chain_flags_get_type (void)
{
    static GType etype = 0;
    if (G_UNLIKELY(etype == 0)) {
        static const GFlagsValue values[] = {
            { GCR_CERTIFICATE_CHAIN_NONE, "GCR_CERTIFICATE_CHAIN_NONE", "none" },
            { GCR_CERTIFICATE_CHAIN_NO_LOOKUPS, "GCR_CERTIFICATE_CHAIN_NO_LOOKUPS", "no-lookups" },
            { 0, NULL, NULL }
        };
        etype = g_flags_register_static (g_intern_static_string ("GcrCertificateChainFlags"), values);
    }
    return etype;
}
#include "gcr/gcr-certificate-request.h"
/* enumerations from "gcr/gcr-certificate-request.h" */
GType gcr_certificate_request_format_get_type (void) G_GNUC_CONST;

GType
gcr_certificate_request_format_get_type (void)
{
    static GType etype = 0;
    if (G_UNLIKELY(etype == 0)) {
        static const GEnumValue values[] = {
            { GCR_CERTIFICATE_REQUEST_PKCS10, "GCR_CERTIFICATE_REQUEST_PKCS10", "pkcs10" },
            { 0, NULL, NULL }
        };
        etype = g_enum_register_static (g_intern_static_string ("GcrCertificateRequestFormat"), values);
    }
    return etype;
}
#include "gcr/gcr-column.h"
/* enumerations from "gcr/gcr-column.h" */
GType gcr_column_flags_get_type (void) G_GNUC_CONST;

GType
gcr_column_flags_get_type (void)
{
    static GType etype = 0;
    if (G_UNLIKELY(etype == 0)) {
        static const GFlagsValue values[] = {
            { GCR_COLUMN_NONE, "GCR_COLUMN_NONE", "none" },
            { GCR_COLUMN_HIDDEN, "GCR_COLUMN_HIDDEN", "hidden" },
            { GCR_COLUMN_SORTABLE, "GCR_COLUMN_SORTABLE", "sortable" },
            { 0, NULL, NULL }
        };
        etype = g_flags_register_static (g_intern_static_string ("GcrColumnFlags"), values);
    }
    return etype;
}
#include "gcr/gcr-deprecated-base.h"
/* enumerations from "gcr/gcr-deprecated-base.h" */
GType gcr_importer_prompt_behavior_get_type (void) G_GNUC_CONST;

GType
gcr_importer_prompt_behavior_get_type (void)
{
    static GType etype = 0;
    if (G_UNLIKELY(etype == 0)) {
        static const GEnumValue values[] = {
            { GCR_IMPORTER_PROMPT_NEEDED, "GCR_IMPORTER_PROMPT_NEEDED", "needed" },
            { GCR_IMPORTER_PROMPT_ALWAYS, "GCR_IMPORTER_PROMPT_ALWAYS", "always" },
            { GCR_IMPORTER_PROMPT_NEVER, "GCR_IMPORTER_PROMPT_NEVER", "never" },
            { 0, NULL, NULL }
        };
        etype = g_enum_register_static (g_intern_static_string ("GcrImporterPromptBehavior"), values);
    }
    return etype;
}
#include "gcr/gcr-prompt.h"
/* enumerations from "gcr/gcr-prompt.h" */
GType gcr_prompt_reply_get_type (void) G_GNUC_CONST;

GType
gcr_prompt_reply_get_type (void)
{
    static GType etype = 0;
    if (G_UNLIKELY(etype == 0)) {
        static const GEnumValue values[] = {
            { GCR_PROMPT_REPLY_CANCEL, "GCR_PROMPT_REPLY_CANCEL", "cancel" },
            { GCR_PROMPT_REPLY_CONTINUE, "GCR_PROMPT_REPLY_CONTINUE", "continue" },
            { 0, NULL, NULL }
        };
        etype = g_enum_register_static (g_intern_static_string ("GcrPromptReply"), values);
    }
    return etype;
}
#include "gcr/gcr-system-prompt.h"
/* enumerations from "gcr/gcr-system-prompt.h" */
GType gcr_system_prompt_error_get_type (void) G_GNUC_CONST;

GType
gcr_system_prompt_error_get_type (void)
{
    static GType etype = 0;
    if (G_UNLIKELY(etype == 0)) {
        static const GEnumValue values[] = {
            { GCR_SYSTEM_PROMPT_IN_PROGRESS, "GCR_SYSTEM_PROMPT_IN_PROGRESS", "progress" },
            { 0, NULL, NULL }
        };
        etype = g_enum_register_static (g_intern_static_string ("GcrSystemPromptError"), values);
    }
    return etype;
}
#include "gcr/gcr-system-prompter.h"
/* enumerations from "gcr/gcr-system-prompter.h" */
GType gcr_system_prompter_mode_get_type (void) G_GNUC_CONST;

GType
gcr_system_prompter_mode_get_type (void)
{
    static GType etype = 0;
    if (G_UNLIKELY(etype == 0)) {
        static const GEnumValue values[] = {
            { GCR_SYSTEM_PROMPTER_SINGLE, "GCR_SYSTEM_PROMPTER_SINGLE", "single" },
            { GCR_SYSTEM_PROMPTER_MULTIPLE, "GCR_SYSTEM_PROMPTER_MULTIPLE", "multiple" },
            { 0, NULL, NULL }
        };
        etype = g_enum_register_static (g_intern_static_string ("GcrSystemPrompterMode"), values);
    }
    return etype;
}
#include "gcr/gcr-types.h"
/* enumerations from "gcr/gcr-types.h" */
GType gcr_data_error_get_type (void) G_GNUC_CONST;

GType
gcr_data_error_get_type (void)
{
    static GType etype = 0;
    if (G_UNLIKELY(etype == 0)) {
        static const GEnumValue values[] = {
            { GCR_ERROR_FAILURE, "GCR_ERROR_FAILURE", "failure" },
            { GCR_ERROR_UNRECOGNIZED, "GCR_ERROR_UNRECOGNIZED", "unrecognized" },
            { GCR_ERROR_CANCELLED, "GCR_ERROR_CANCELLED", "cancelled" },
            { GCR_ERROR_LOCKED, "GCR_ERROR_LOCKED", "locked" },
            { 0, NULL, NULL }
        };
        etype = g_enum_register_static (g_intern_static_string ("GcrDataError"), values);
    }
    return etype;
}
GType gcr_data_format_get_type (void) G_GNUC_CONST;

GType
gcr_data_format_get_type (void)
{
    static GType etype = 0;
    if (G_UNLIKELY(etype == 0)) {
        static const GEnumValue values[] = {
            { GCR_FORMAT_ALL, "GCR_FORMAT_ALL", "all" },
            { GCR_FORMAT_INVALID, "GCR_FORMAT_INVALID", "invalid" },
            { GCR_FORMAT_DER_PRIVATE_KEY, "GCR_FORMAT_DER_PRIVATE_KEY", "der-private-key" },
            { GCR_FORMAT_DER_PRIVATE_KEY_RSA, "GCR_FORMAT_DER_PRIVATE_KEY_RSA", "der-private-key-rsa" },
            { GCR_FORMAT_DER_PRIVATE_KEY_DSA, "GCR_FORMAT_DER_PRIVATE_KEY_DSA", "der-private-key-dsa" },
            { GCR_FORMAT_DER_PRIVATE_KEY_EC, "GCR_FORMAT_DER_PRIVATE_KEY_EC", "der-private-key-ec" },
            { GCR_FORMAT_DER_SUBJECT_PUBLIC_KEY, "GCR_FORMAT_DER_SUBJECT_PUBLIC_KEY", "der-subject-public-key" },
            { GCR_FORMAT_DER_CERTIFICATE_X509, "GCR_FORMAT_DER_CERTIFICATE_X509", "der-certificate-x509" },
            { GCR_FORMAT_DER_PKCS7, "GCR_FORMAT_DER_PKCS7", "der-pkcs7" },
            { GCR_FORMAT_DER_PKCS8, "GCR_FORMAT_DER_PKCS8", "der-pkcs8" },
            { GCR_FORMAT_DER_PKCS8_PLAIN, "GCR_FORMAT_DER_PKCS8_PLAIN", "der-pkcs8-plain" },
            { GCR_FORMAT_DER_PKCS8_ENCRYPTED, "GCR_FORMAT_DER_PKCS8_ENCRYPTED", "der-pkcs8-encrypted" },
            { GCR_FORMAT_DER_PKCS10, "GCR_FORMAT_DER_PKCS10", "der-pkcs10" },
            { GCR_FORMAT_DER_SPKAC, "GCR_FORMAT_DER_SPKAC", "der-spkac" },
            { GCR_FORMAT_BASE64_SPKAC, "GCR_FORMAT_BASE64_SPKAC", "base64-spkac" },
            { GCR_FORMAT_DER_PKCS12, "GCR_FORMAT_DER_PKCS12", "der-pkcs12" },
            { GCR_FORMAT_OPENSSH_PUBLIC, "GCR_FORMAT_OPENSSH_PUBLIC", "openssh-public" },
            { GCR_FORMAT_OPENPGP_PACKET, "GCR_FORMAT_OPENPGP_PACKET", "openpgp-packet" },
            { GCR_FORMAT_OPENPGP_ARMOR, "GCR_FORMAT_OPENPGP_ARMOR", "openpgp-armor" },
            { GCR_FORMAT_PEM, "GCR_FORMAT_PEM", "pem" },
            { GCR_FORMAT_PEM_PRIVATE_KEY_RSA, "GCR_FORMAT_PEM_PRIVATE_KEY_RSA", "pem-private-key-rsa" },
            { GCR_FORMAT_PEM_PRIVATE_KEY_DSA, "GCR_FORMAT_PEM_PRIVATE_KEY_DSA", "pem-private-key-dsa" },
            { GCR_FORMAT_PEM_CERTIFICATE_X509, "GCR_FORMAT_PEM_CERTIFICATE_X509", "pem-certificate-x509" },
            { GCR_FORMAT_PEM_PKCS7, "GCR_FORMAT_PEM_PKCS7", "pem-pkcs7" },
            { GCR_FORMAT_PEM_PKCS8_PLAIN, "GCR_FORMAT_PEM_PKCS8_PLAIN", "pem-pkcs8-plain" },
            { GCR_FORMAT_PEM_PKCS8_ENCRYPTED, "GCR_FORMAT_PEM_PKCS8_ENCRYPTED", "pem-pkcs8-encrypted" },
            { GCR_FORMAT_PEM_PKCS12, "GCR_FORMAT_PEM_PKCS12", "pem-pkcs12" },
            { GCR_FORMAT_PEM_PRIVATE_KEY, "GCR_FORMAT_PEM_PRIVATE_KEY", "pem-private-key" },
            { GCR_FORMAT_PEM_PKCS10, "GCR_FORMAT_PEM_PKCS10", "pem-pkcs10" },
            { GCR_FORMAT_PEM_PRIVATE_KEY_EC, "GCR_FORMAT_PEM_PRIVATE_KEY_EC", "pem-private-key-ec" },
            { GCR_FORMAT_PEM_PUBLIC_KEY, "GCR_FORMAT_PEM_PUBLIC_KEY", "pem-public-key" },
            { 0, NULL, NULL }
        };
        etype = g_enum_register_static (g_intern_static_string ("GcrDataFormat"), values);
    }
    return etype;
}
 /**/

/* Generated data ends here */

